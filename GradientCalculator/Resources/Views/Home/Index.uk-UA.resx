<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="general_provisions_content_text" xml:space="preserve">
    <value>&lt;p&gt;Розглянемо завдання безумовної мінімізації
&lt;em&gt;f (x) → inf, x∈R&lt;sup&gt;n&lt;/sup&gt;&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;(1). &lt;/p&gt;
&lt;p&gt; Будь-який числовий метод розв’язування задачі оптимізації ґрунтується на точному або наближеному обчисленні певних характеристик (значення функції мети, значення похідних тощо). На основі отриманої інформації будуємо наближення до розв’язку задачі. Це може бути значення &lt;em&gt;x&lt;sub&gt;*&lt;/sub&gt;&lt;/em&gt;, множина значень &lt;em&gt;X&lt;sub&gt;*&lt;/sub&gt;&lt;/em&gt; або значення функції мети &lt;em&gt;f&lt;sub&gt;*&lt;/sub&gt; = min f(x)&lt;/em&gt;.&lt;/p&gt; 
&lt;p&gt;Для кожної конкретної задачі питання про характеристики функції, які потрібно брати до уваги під час розв’язування задачі, залежать від властивості функції, а також наявності можливостей зі збереження і обробки інформації. Наприклад, якщо ємність пам’яті ЕОМ мала, то у процесі розв’язування задач високої розмірності не доцільно використовувати алгоритми, в яких є похідні другого порядку, для недиференційованих функцій не можна застосовувати методи, які потребують обчислення градієнта і т. д.&lt;/p&gt;
&lt;p&gt;Алгоритми, які використовують лише інформацію про значення мінімізаційної функції, називають &lt;em&gt;алгоритмами нульового порядку&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;&lt;b&gt;Алгоритми першого та другого порядків&lt;/b&gt; використовують інформацію, відповідно, про значення перших і других похідних. Розглянемо лише  алгоритми першого та другого порядків або їхні модифікації. Для мінімізації функції багатьох змінних користуватимемося послідовними алгоритмами, коли вибір наступного наближення залежить від попередніх результатів.&lt;/p&gt;
&lt;p&gt;У цьому випадку застосовуватимемо алгоритми вигляду&lt;/p&gt;
&lt;p&gt;&lt;em&gt;x&lt;sub&gt;k+1&lt;/sub&gt;=x&lt;sub&gt;k&lt;/sub&gt;+a&lt;sub&gt;k&lt;/sub&gt;*h&lt;sub&gt;k&lt;/sub&gt;,&amp;nbsp;&amp;nbsp;&amp;nbsp;де a&lt;sub&gt;k&lt;/sub&gt;∈R&lt;sup&gt;n&lt;/sup&gt;,&amp;nbsp;&amp;nbsp;&amp;nbsp;k=0,1,2…&lt;/em&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;(2)&lt;/p&gt;
&lt;p&gt;Конкретний алгоритм визначається заданням початкового наближення &lt;em&gt;x&lt;sub&gt;0&lt;/sub&gt;&lt;/em&gt;, правилом вибору напряму &lt;em&gt;h&lt;sub&gt;k&lt;/sub&gt;&lt;/em&gt; і чисел &lt;em&gt;a&lt;sub&gt;k&lt;/sub&gt;&lt;/em&gt; залежно від інформації, яку отримали на підставі попередніх обчислень, а також правилом умов зупинки. Вектор &lt;em&gt;h&lt;sub&gt;k&lt;/sub&gt;&lt;/em&gt; визначає напрям (k+1)-го кроку методу мінімізації, а коефіцієнт &lt;em&gt;a&lt;sub&gt;k&lt;/sub&gt;&lt;/em&gt; - довжину цього кроку.&lt;/p&gt;
&lt;p&gt;На практиці  &lt;em&gt;a&lt;sub&gt;k&lt;/sub&gt;&gt;0&lt;/em&gt; часто обирають з умови забезпечення монотонності &lt;em&gt;f(x&lt;sub&gt;k+1&lt;/sub&gt;)&amp;lt;f(x&lt;sub&gt;k&lt;/sub&gt;)&lt;/em&gt;. У цьому випадку задають &lt;em&gt;a&lt;sub&gt;k&lt;/sub&gt;=a&lt;/em&gt; і перевіряють монотонність. Якщо монотонність не виконується, то  a дроблять доти, доки ця умова не виконається.&lt;/p&gt;
&lt;p&gt;Серед методів мінімізації можна умовно виділити скінченні і нескінченні. Скінченними методами є такі, які гарантують знаходження розв’язку задачі за скінченну кількість операцій (кроків, ітерацій). У цьому випадку вважаємо, що обчислення проводимо точно&lt;/p&gt;
&lt;p&gt;Важливою характеристикою нескінченних методів є швидкість збіжності. Метод (2) збігається, якщо &lt;em&gt;ρ(x&lt;sub&gt;k&lt;/sub&gt;, x&lt;sub&gt;*&lt;/sub&gt;)→0 (k→∞)&lt;/em&gt;, де  &lt;em&gt;x&lt;sub&gt;*&lt;/sub&gt;&lt;/em&gt; є розв’язком задачі (1). Якщо &lt;em&gt;f(x&lt;sub&gt;k&lt;/sub&gt;)→f(x&lt;sub&gt;*&lt;/sub&gt;)&lt;/em&gt;, то іноді також говорять, що метод (2) збігається за функцією.&lt;/p&gt;
&lt;p&gt;У випадку, коли точка &lt;em&gt;x&lt;sub&gt;*&lt;/sub&gt;&lt;/em&gt; не єдина, то під збіжністю послядовності &lt;em&gt;{x&lt;sub&gt;k&lt;/sub&gt;}&lt;/em&gt; розміють збіжність до множини &lt;em&gt;X&lt;sub&gt;*&lt;/sub&gt;={x&lt;sub&gt;*&lt;/sub&gt;∈R&lt;sup&gt;n&lt;/sup&gt;:f(x&lt;sub&gt;*&lt;/sub&gt;)=min ⁡f(x) }, ρ(x&lt;sub&gt;k&lt;/sub&gt;, X&lt;sub&gt;*&lt;/sub&gt;)→0 (k→∞)&lt;/em&gt;. Ефективність методів можна в певному сенсі охарактеризувати за допомогою поняття швидкості збіжності.&lt;/p&gt;</value>
  </data>
  <data name="general_provisions_content_title" xml:space="preserve">
    <value>Загальні положення</value>
  </data>
  <data name="main_content_text" xml:space="preserve">
    <value>&lt;p&gt;Градієнтні методи належать до наближених числових методів розв’язування задач нелінійного програмування, оскільки дають точний розв’язок за нескінченне і, лише в окремих випадках, за скінченне число кроків. З їх використанням можна розв’язувати будь-яку задачу нелінійного програмування, знаходячи, як правило, лише локальний екстремум.&lt;/p&gt;
&lt;p&gt;Ідея градієнтних методів базується на тому, що напрямок градієнта є напрямком найшвидшого зростання функції. Отже, протилежний напрямок є напрямком найшвидшого спадання функції градієнта перпендикулярний в будь-якій точці лінії постійного рівня, оскільки уздовж цієї лінії значення функції є сталим. В &lt;b&gt;методі найшвидшого спуску&lt;/b&gt; пошук мінімуму функції здійснюється вздовж напрямку, оберненого до напрямку градієнту. Як критерій завершення обчислень, найчастіше використовується близькість до нуля градієнту. Основною складністю застосування методу найшвидшого спуску є залежність його від вибору масштабу змінних що оптимізуються.&lt;/p&gt;
&lt;p&gt;В методах, що використовують другі похідні, використовується матриця Гессе, яку необхідно інвертувати на кожному кроці, як в &lt;b&gt;методі Ньютона – Рафсона&lt;/b&gt;. Оскільки ця процедура може займати основний час обчислень, використовуються наближення до неї, і позитивно визначена симетрична матриця у остаточному рахунку при виконанні певних умов стає рівною асимптотично матриці Гессе, як у &lt;b&gt;методі Давідсона – Флетчера – Павела&lt;/b&gt;.&lt;/p&gt;
&lt;p&gt;Основна ідея &lt;b&gt;методу штрафів&lt;/b&gt; для розв язання задачі оптимізації з обмеженнями полягає у перетворенні задачі мінімізації функції з обмеженнями у задачу пошуку мінімуму без обмежень модифікованої функції, в якій при порушенні обмежень додаткова складова, сформована на основі обмежень  «штрафувала» б модифіковану функцію, збільшуючи її значення. На цій ідеї побудовані &lt;b&gt;метод Фіако-Маккорміка&lt;/b&gt;, який у якості кроку алгоритму використовує метод Давідсона-Флетчера-Павела та &lt;b&gt;метод Бокса&lt;/b&gt;, який, по суті, є модифікацією симплексного методу Непдера-Міда, що дозволяє враховувати обмеження.&lt;/p&gt;
&lt;p&gt;Ще один метод призначений для знаходження розв'язку задачі нелінійного програмування, а саме &lt;b&gt;метод Франка-Вульфа&lt;/b&gt;, який відноситься до категорії градієнтних методів і процедура якого передбачає визначення оптимального плану шляхом перебору розв'язків, які є допустимими планами задачі.&lt;/p&gt;
</value>
  </data>
  <data name="main_content_title" xml:space="preserve">
    <value>Градієнтні методи</value>
  </data>
  <data name="page_title" xml:space="preserve">
    <value>Головна</value>
  </data>
</root>